/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "rcc_assembly.h"
#include "gpio_assembly.h"
#include "tim_assembly.h"
#include "pwd_assembly.h"
#include "adc_assembly.h"
#include "nvic_assembly.h"
//#include "dma_assembly.h"
#include "dma_adc4_assembly.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile uint32_t status_interrupts = 0;


volatile uint32_t dma_status_interrupts = 0;

volatile int count = 0;
volatile int calibrate = 0;
volatile int adc_enabled = 0;
volatile int adc_started = 0;

uint16_t buff = 0;


int main(void)
{
	//uint32_t* buff = (uint32_t) 0x20000010;

	//enable VDDA power source
	RCC_PWR_Set_Clock();
	PWD_Set_VDDA_AVM1EN();
	while(PWD_Get_VDDA1RDY() == 0);
	PWD_Set_VDDA_ASV();
	RCC_PWR_Clear_Clock();

	//enable GPIOA
	RCC_GPIOA_Set_Clock();
	GPIOA_Set_Alt_Funtion_Mode();
	GPIOA_Set_Alt_Function();

	//configure TIM2 timer
	RCC_TIM2_Set_Clock();
	TIM2_Set_PSC_Value();
	TIM2_Set_ARR_Value();
	TIM2_Clear_UIF_Flag();
	TIM2_Set_CCnS_To_Channel_Output();
	TIM2_Set_DITHEN_False();
	TIM2_Set_CCRn_WaveGen_Value();
	TIM2_Set_DIR_UpCounter();
	TIM2_Set_MMS_Update_Trigger_Output();
	TIM2_Set_OCnM_To_Toggle_Mode();
	TIM2_Set_CC1P_Polarity_ActiveHigh();
	TIM2_Set_CCnE_Output_Enable_To_GPIO();
	TIM2_Set_UIF_Update_Interrupt_Enable();
	TIM2_Set_CC1IE_Update_Interrupt_Enable();
	NVIC_TIM2_Enable_Interupt();

	//enable GPIOH
	RCC_GPIOH_Set_Clock();
	GPIOH_Set_BSRR_LED_Red();	//to turn off
	GPIOH_Set_Moder_LED_Red();
	GPIOH_Set_BSRR_LED_Green();	//to turn off
	GPIOH_Set_Moder_LED_Green();

	//configure ADC4
	RCC_ADC4_Set_Clock();
	ADC4_Set_Prescaler();
	ADC4_Set_CHSELR_mode_to_all_bits_input();
	ADC4_Set_CHSELR_Internal_Temp_Sensor();
	ADC4_Set_OVRMOD_Override();
	ADC4_Enable_Interrupts();
	NVIC_ADC4_Enable_Interupt();
	CreateDelayLoop(100000);
	ADC4_Clear_VoltageRegulator_ready_flag();
	ADC4_Enable_VoltageRegulator();

	//configure DMA
	RCC_DMA1_Set_Clock();
	DMA_SECCFGR_Set_Nonsecure();
	DMA_PRIVCFGR_Set_Unprivileged();
	//block size
	DMA_C0BR1_BNDT();
	DMA_C0CR_PRIO_Channel_Priority_0();
	DMA_C0TR1_SAP_Port_0();
	DMA_C0TR2_SWREQ_Software_Request_0();
	DMA_C0TR2_REQSEL_Hardware_Request_ADC4_DMA();
	DMA_C0SAR_Source_Address();
	DMA_C0TR1_SINC_Fixed();
	//DMA_C0TR1_SINC_Continuous();
	DMA_C0TR1_SDW_LOG2_Source_Data_Width_16();
	DMA_C0TR1_SBL_1_Burst_Lenght_Single();

	DMA_C0TR1_DAP_Port_1();
	DMA_C0DAR_Destination_Address();
	//DMA_C0TR1_DINC_Fixed();
	DMA_C0TR1_DINC_Continuous();
	//DMA_C0TR1_DDW_LOG2_Source_Data_Width_32();
	DMA_C0TR1_DDW_LOG2_Source_Data_Width_16();
	DMA_C0TR1_DBL_1_Burst_Lenght_Single();
	//DMA_C0TR1_DBL_1_Burst_Lenght_N();

	DMA_C0CR_Set_Interrupts();
	NVIC_DMA1_Enable_Interupt();
	DMA_C0CR_Set_Enable();



    /* Loop forever */
 	for(;;);
}

volatile int countRed = 0;
volatile int countGreen = 0;
volatile uint16_t status_flags;
void TIM2_IRQHandler(){
	status_flags = TIM2_Get_SR_Status();
	if(status_flags & 0b01){
		if(countRed % 2){
			GPIOH_Set_BSRR_LED_Red(); //to turn on
		}
		else{
			GPIOH_Clear_BSRR_LED_Red();	//to turn off
		}
		TIM2_Clear_UIF_Flag();
		++countRed;
	}

//	if(status_flags & 0b10){
//		if(countGreen % 2){
//			GPIOH_Set_BSRR_LED_Green(); //to turn on
//		}
//		else{
//			GPIOH_Clear_BSRR_LED_Green();	//to turn off
//		}
//		TIM2_Clear_CC1IF_Flag();
//		++countGreen;
//	}
}


void ADC4_IRQHandler(){
	//uint16_t converted_value;
	status_interrupts = ADC4_Get_Interrupt_Adc_Status();
	//count++;

	if(status_interrupts & 0b100){ //end of conversion
	//	converted_value = ADC4_Get_DR();

		return;
	}

	if(status_interrupts & 0b10000){ //overrun occured
		ADC4_Clear_OVR_flag();
		return;
	}

	if(status_interrupts & 0x1){ //adc enabled
		if(adc_started == 0){
			ADC4_Clear_ADRDYIE_Interrupts();
			ADC4_Start();
			TIM2_Set_CEN_Counter_Enable();
		}
		adc_started = 1;
		return;
	}

	if(status_interrupts & 0b100000000000){ //calibration complete

		if(adc_enabled == 0){
			ADC4_Set_SMPR_SamplingTime();
			ADC4_Set_SMPR_SamplingTimeSource();
			ADC4_Set_Single();
			ADC4_Enable_CCR_Voltage_Reference();
			ADC4_Set_EXTSEL_TIM2_ConversionTrigger();
			ADC4_Set_EXTEN_TriggerPolarity(1);
			//This is where you set DMA in ADC_CFGR1 register: DMAEN = 1 and DMACFG = 1
			ADC4_DMAEN_Mode_Enable();
			//ADC4_DMACFG_Circular_Set();
			ADC4_DMACFG_OneShot_Set();
			ADC4_Enable_CCR_TemperatureSensor();
			ADC4_Enable();
			ADC4_Clear_EOCALIE_Interrupts();
		}
		adc_enabled = 1;
		return;
	}

	if(status_interrupts & 0b1000000000000){ //voltage regulator ready
		if (calibrate == 0){
			ADC4_Calibrate();
			ADC4_Clear_LDORDYIE_Interrupts();
		}
		calibrate = 1;
		return;
	}
}

void GPDMA1_CH0_IRQHandler(){

	dma_status_interrupts = DMA_C0SR_Flags();
	if (dma_status_interrupts & 0b1000000000 ){
		buff = DMA_Get_Converted_Value();

	}


	return;

}
