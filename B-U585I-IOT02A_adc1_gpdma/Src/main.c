/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <tim2_assembly.h>
#include "rcc_assembly.h"
#include "adc1_assembly.h"
#include "pwd_assembly.h"
#include "nvic_assembly.h"
#include "tim8_assembly.h"
#include "gpio_assembly.h"
#include "gpdma_ch15_assembly.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/*
 TS_CAL1 Temperature sensor 14-bit raw data
acquired by ADC1 at 30 °C (± 5 °C),
VDDA = VREF+ = 3.0 V (±10 mV)
0x0BFA 0710 -
0x0BFA 0711

TS_CAL2Temperature sensor 14-bit raw data
acquired by ADC1 at 130 °C (± 5 °C),
VDDA = VREF+ = 3.0 V (±10 mV)
0x0BFA 0742 -
0x0BFA 0743
 */
//Define temperature sensor calibration points
#define TS_CAL1_TEMP 30 //TS_CAL1 Temperature sensor 14-bit raw data acquired by ADC1 at 30 °C (± 5 °C),
#define TS_CAL2_TEMP 130 //TS_CAL2Temperature sensor 14-bit raw data acquired by ADC1 at 130 °C (± 5 °C),
//Memory addresses for calibration value
#define TS_CAL1 ((uint16_t*)0x0BFA0710)
#define TS_CAL2 ((uint16_t*)0x0BFA0742)

float get_temp(uint32_t dr);

float get_temp(uint32_t dr){
	uint16_t ts_cal1 = *TS_CAL1;
	uint16_t ts_cal2 = *TS_CAL2;
	float TS_CAL_TEMP_DIFF = (TS_CAL2_TEMP - TS_CAL1_TEMP);
	float ts_cal_diff = (ts_cal2-ts_cal1);
	float diff = ((float)dr-ts_cal1);
	float temp	 = ((TS_CAL_TEMP_DIFF/ts_cal_diff) * diff) + TS_CAL1_TEMP + 66.50150108;

	return temp;
}

volatile uint16_t _dma[64];

volatile int adc_calibrate = 0;
volatile int adc_enabled = 0;
volatile int adc_started = 0;
int main(void)
{
	_dma[0]=1;  //Ox2000001c
	//PWD
	//enable VDDA power source
	RCC_AHB3ENR_PWREN_Set();
	PWD_SVMCR_AVM1EN_Vdda_Set();
	while(PWD_SVMSR_VDDA1RDY_Get() == 0);
	PWD_SVMCR_ASV_Vdda_Set();
	//RCC_AHB3ENR_PWREN_Clear();

	//enable GPIOA
	RCC_AHB2ENR1_GPIOAEN_Set();
	GPIOA_Set_Alt_Funtion_Mode();
	GPIOA_Set_Alt_Function();

	//enable GPIOH
	RCC_AHB2ENR1_GPIOHEN_Set();
	GPIOH_Set_BSRR_LED_Red();	//to turn off
	GPIOH_Set_Moder_LED_Red();
	GPIOH_Set_BSRR_LED_Green();	//to turn off
	GPIOH_Set_Moder_LED_Green();

	//configure TIM2 timer
	RCC_APB2ENR_TIM8EN_Set();
	TIM8_Set_PSC_Value();
	TIM8_Set_ARR_Value();
	TIM8_Clear_UIF_Flag();
	TIM8_Set_CCnS_To_Channel_Output();
	TIM8_Set_DITHEN_False();
	TIM8_Set_CCRn_WaveGen_Value();
	TIM8_Set_DIR_UpCounter();
	TIM8_Set_MMS_Update_Trigger_Output();
	//TIM8_Set_OCnM_To_Toggle_Mode();
	TIM8_Set_CC1P_Polarity_ActiveHigh();
	TIM8_Set_CCnE_Output_Enable_To_GPIO();
	TIM8_Set_UIF_Update_Interrupt_Enable();
	TIM8_Set_CC1IE_Update_Interrupt_Enable();
	NVIC_TIM8_Enable_Interupt();

	//TIM8_Set_CEN_Counter_Enable();


	//ADC
	RCC_AHB2ENR1_ADC12EN_Set();
	ADC12_CCR_PRESC_4();

		//voltage regulator
	ADC1_DEEPPWD_Clear();
	ADC1_CR_ADVREGEN_Set();
	while(ADC1_ISR_LDORDY_Get() == 0);
		//calibrate
	ADC1_CR_ADCALLIN_Set();
	ADC1_CALFACT_CAPTURE_COEF_Clear();
	ADC1_CALFACT_LATCH_COEF_Clear();
	ADC1_CR_ADCAL_Set();
	adc_calibrate = 1;
	while(ADC1_CR_ADCAL_Get() !=0){}
		//channel selection
	uint8_t ch19_internal_temp = 0x13;    	//19th channel = hex13
	ADC1_PCSEL_PCSEL_Set(ch19_internal_temp);
	ADC1_DIFSEL_DIFSEL_SingleEnded(ch19_internal_temp);
	ADC1_SQR1_SQ1(ch19_internal_temp);
	ADC1_SMPR2_SMP19_20CLK();
	//ADC1_SMPR2_SMP19_5CLK();
	//ADC1_SMPR2_SMP19_12CLK();
	//ADC1_SMPR2_SMP19_814CLK();
	ADC12_CCR_VSENSESEL_Set();
	ADC1_SQR1_L(0);
		//configuration
	ADC1_CFGR1_DMNGT_DmaOneShot();
	//ADC1_CFGR1_DMNGT_DmaCircular();
	//ADC1_CFGR1_DMNGT_Regular();
	ADC1_CFGR1_CONT_Single();
	//ADC1_CFGR1_CONT_Continuos();
	ADC1_CFGR1_OVRMOD_Overwrite();
	//ADC1_CFGR1_AUTDLY_Set();
		//external trigger TIM8
	ADC1_CFGR1_EXTEN(1);
	ADC1_CFGR1_EXTSEL();
		//interrupts
	ADC1_IER_Set();
	NVIC_ADC12_Enable_Interupt();

	ADC1_CR_ADEN();
	adc_enabled = 1;


/*
	//configure DMA
	RCC_DMA1_Set_Clock();
	DMA_SECCFGR_Set_Nonsecure();
	DMA_PRIVCFGR_Set_Unprivileged();

	//block size
	DMA_C0BR1_BNDT();
	DMA_C0BR1_BRC();
	DMA_C0CR_PRIO_Channel_Priority_0();
	DMA_C0TR1_SAP_Port_0();
	DMA_C0TR2_SWREQ_Software_Request_0();
	//DMA_C0TR2_REQSEL_Hardware_Request_ADC4_DMA();
	DMA_C0TR2_REQSEL_Hardware_Request_ADC1_DMA();
	DMA_C0SAR_Source_Address();
	DMA_C0TR1_SINC_Fixed();
	//DMA_C0TR1_SINC_Continuous();
	DMA_C0TR1_SDW_LOG2_Source_Data_Width_16();
	DMA_C0TR1_SBL_1_Burst_Lenght_Single();

	DMA_C0TR1_DAP_Port_1();
	DMA_C0DAR_Destination_Address();
	//DMA_C0TR1_DINC_Fixed();
	DMA_C0TR1_DINC_Continuous();
	//DMA_C0TR1_DDW_LOG2_Source_Data_Width_32();
	DMA_C0TR1_DDW_LOG2_Source_Data_Width_16();
	DMA_C0TR1_DBL_1_Burst_Lenght_Single();
	//DMA_C0TR1_DBL_1_Burst_Lenght_N();

	DMA_C0CR_Set_Interrupts();
	NVIC_DMA1_Enable_Interupt();
	DMA_C0CR_Set_Enable();
*/
	//configure DMA
	RCC_DMA1_Set_Clock();
	DMA_SECCFGR_Set_Nonsecure();
	DMA_PRIVCFGR_Set_Unprivileged();

	//block size
	DMA_C15BR1_BNDT();
	//DMA_C15BR1_BRC();
	DMA_C15CR_PRIO_Channel_Priority_0();
	DMA_C15TR1_SAP_Port_0();
	DMA_C15TR2_SWREQ_Software_Request_0();
	//DMA_C15TR2_REQSEL_Hardware_Request_ADC4_DMA();
	DMA_C15TR2_REQSEL_Hardware_Request_ADC1_DMA();
	DMA_C15SAR_Source_Address();
	DMA_C15TR1_SINC_Fixed();
	//DMA_C15TR1_SINC_Continuous();
	DMA_C15TR1_SDW_LOG2_Source_Data_Width_16();
	DMA_C15TR1_SBL_1_Burst_Lenght_Single();
	//DMA_C15TR1_SBL_1_Burst_Lenght_2();

	DMA_C15TR1_DAP_Port_1();
	DMA_C15DAR_Destination_Address();
	//DMA_C15TR1_DINC_Fixed();
	DMA_C15TR1_DINC_Continuous();
	//DMA_C15TR1_DDW_LOG2_Source_Data_Width_32();
	DMA_C15TR1_DDW_LOG2_Source_Data_Width_16();
	DMA_C15TR1_DBL_1_Burst_Lenght_Single();
	//DMA_C15TR1_DBL_1_Burst_Lenght_N();

	DMA_C15CR_Set_Interrupts();
	NVIC_DMA1_Enable_Interupt();
	DMA_C15CR_Set_Enable();

	for(;;);
}


volatile int countRed = 0;
volatile int countGreen = 0;
volatile uint32_t adc_interrupts_status;
volatile float raw_value;
volatile float temperature;
volatile int conversion_flag = 0;

void ADC12_IRQHandler(){
	adc_interrupts_status = ADC1_ISR_State();

	if(adc_interrupts_status & 0b100){ 	//end of conversion
//		raw_value = ADC1_DR_Get();
//		temperature = get_temp(raw_value);

		conversion_flag ^=1;
		if(conversion_flag){
			GPIOH_Set_BSRR_LED_Green(); //to turn on
		}
		else{
			GPIOH_Clear_BSRR_LED_Green();	//to turn off
		}
		TIM8_Clear_UIF_Flag();
		return;
	}

	if(adc_interrupts_status & 0b1000){ 	//end of sequence

			TIM8_Clear_UIF_Flag();
			return;
	}

	if(adc_interrupts_status & 0b10000){ //overrun occurred
		ADC1_ISR_OVR_Clear();
		return;
	}

	if((adc_interrupts_status & 0b1)){ //0b1 ADC is ready
		if(adc_started == 0){
			ADC1_IER_ADRDYIE_Clear();
			ADC1_CR_ADSTART();
			TIM8_Set_CEN_Counter_Enable();

		}
		adc_started = 1;
		return;
	}
}

volatile uint32_t status_flags;
int tim_flag = 0;
void TIM8_UP_IRQHandler(){
	status_flags = TIM8_Get_SR_Status();
	if(status_flags & 0x1){  //UIF on
		TIM8_Clear_UIF_Flag();
		tim_flag ^= 1;
	}
}





